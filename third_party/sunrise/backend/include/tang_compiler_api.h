/*
Copyright declaration.
*/

#ifndef _TANG_RT_TANG_COMPILER_API_H
#define _TANG_RT_TANG_COMPILER_API_H

#include "tang_rt/driver_types.h"
#include "tang_rt/host_defines.h"
#include "tang_rt/vector_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief C compliant register fatbinary API
 *
 * @param [in] fatTangbin - pointer of tang fatbin data
 *
 * @returns tang fatbin handle registered in runtime
 *
 */
TANGRT_API_PUBLIC void** __tangRegisterFatBinary(void* fatTangbin);

/**
 * @brief
 *
 * @param fatbinHandle
 */
TANGRT_API_PUBLIC void __tangRegisterFatBinaryEnd(void** fatbinHandle);

/**
 * @brief C compliant unregister fatbinary API
 *
 * @param [in] fatTangbinHandle - tang fatbin handle registered in runtime
 *
 * @returns void
 *
 */
TANGRT_API_PUBLIC void __tangUnregisterFatBinary(void** fatTangbinHandle);

/**
 * @brief Register fatbinary
 *
 * @param fatbinWrapper
 * @return void**
 * @example
 * @code{.cpp}
 * //!< Generated by compiler
 * const unsigned long fatbinText[] = { 0x12344567, ..., 0xabcd1235 };
 * static __tangFatbinaryWrapper fatbinWrapper = {
 *   .version = 0,
 *   .fatbin = &fatbinText[0],
 *   .size = sizeof(fatbinText),
 * };
 * static void** fatbinHandle;
 * static void __tang_RegisterAll(void) __attribute__((constructor))
 * static void __tang_UnregisterAll(void);
 * static void __tang_RegisterAll(void) {
 *   fatbinHandle = __tangRegisterFatBinary_v2(&fatbinWrapper);
 *   __tangRegisterFunction((const void*)vecadd,
 *                          (const char*)"_Z6vecaddPiS_S_",
 *                          fatbinHandle);
 *   __tangRegisterFatBinaryEnd(fatbinHandle);
 *   atexit(__tang_UnregisterAll);
 * }
 * static void __tang_UnregisterAll(void) {
 *   __tangUnregisterFatBinary_v2(fatbinHandle);
 * }
 * @endcode
 */
TANGRT_API_PUBLIC void** __tangRegisterFatBinary_v2(void* fatbinWrapper);

/**
 * @brief Unregister fatbinary
 *
 * @param fatTangbinHandle
 * @return TANGRT_API_PUBLIC
 */
TANGRT_API_PUBLIC void __tangUnregisterFatBinary_v2(void** fatTangbinHandle);

TANGRT_API_PUBLIC int __tangInitModule(void** fatTangbinHandle);

/**
 * @brief C compliant set fatbinary info API
 *
 * @param [in] fatbinHandle - tang fatbin handle registered in runtime
 * @param [in] info - pointer of tang fatbin info
 *
 * @returns void
 *
 */
TANGRT_API_PUBLIC void __tangSetFatBinaryInfo(void**      fatbinHandle,
                                              const char* info);

/**
 * @brief C compliant register function API
 *
 * @param [in] hostFunc - the pointer of the host stub function
 * @param [in] deviceFuncName - the name string of device function.
 * @param [in] fatbinHandle - tang fatbin handle registered in runtime
 *
 * @returns void
 *
 */
TANGRT_API_PUBLIC void __tangRegisterFunction(const void* hostFunc,
                                              const char* deviceFuncName,
                                              void**      fatbinHandle);

/**
 * @brief Register device variable.
 *
 * @param fatbinHandle The fatbin handle returned by \c __tangRegisterFatBinary
 * @param hostVar The corresponding host variable address used as the key.
 * @param deviceVarAddress The device variable address.
 * @param deviceVarName The symbol name of the devcie variable.
 * @param ext
 * @param size The size of variable in bytes.
 * @param constant If the variable is in const memory ?
 * @param global From the host's point of view, device variable is always local.
 * Thus, param "global" is always 0.
 * @remark
 * For code `__device__ int xyz;` the compiler should generate the following
 * code.
 * @code{.cpp}
 * static int xyz;
 * __tangRegisterVariable(fatbinHandle,
 *                        &xyz, (char*)"xyz", "xyz",
 *                        0, sizeof(int), 0, 0);
 * @endcode
 */
TANGRT_API_PUBLIC void __tangRegisterVariable(void**      fatbinHandle,
                                              const void* hostVar,
                                              char*       deviceVarAddress,
                                              const char* deviceVarName,
                                              int         ext,
                                              size_t      size,
                                              int         constant,
                                              int         global);

/**
 * @brief C compliant push call configuration API
 *
 * @param [in] gridDim - number of blocks in a grid
 * @param [in] blockDim - number of threads in a block
 * @param [in] sharedMemBytes - Amount of dynamic shared memory to allocate for
 * this kernel.  The Kernel can access this with TANG_DYNAMIC_SHARED.
 * @param [in] stream - Stream where the kernel should be dispatched.  May be 0,
 * in which case the default stream is used with associated synchronization
 * rules.
 *
 * @returns #tangSuccess
 *
 */
TANGRT_API_PUBLIC tangError_t
__tangPushCallConfiguration(dim3                  gridDim,
                            dim3                  blockDim,
                            size_t sharedMemBytes __dparm(0),
                            tangStream_t stream   __dparm(0));

/**
 * @brief C compliant pop call configuration API
 *
 * @param [out] gridDim - number of blocks in a grid
 * @param [out] blockDim - number of threads in a block
 * @param [out] sharedMemBytes - Amount of dynamic shared memory to allocate for
 * this kernel.  The Kernel can access this with TANG_DYNAMIC_SHARED.
 * @param [out] stream - Stream where the kernel should be dispatched.  May be
 * 0, in which case the default stream is used with associated synchronization
 * rules.
 *
 * @returns #tangSuccess
 *
 */
TANGRT_API_PUBLIC tangError_t __tangPopCallConfiguration(dim3*   gridDim,
                                                         dim3*   blockDim,
                                                         size_t* sharedMemBytes,
                                                         tangStream_t* stream);

/**
 * @brief C compliant kernel launch API
 *
 * @param [in] hostFunc - the pointer of the host stub function
 * @param [in] gridDim - number of blocks in a grid
 * @param [in] blockDim - number of threads in a block
 * @param [in] args - kernel arguments
 * @param [in] numArgs - number of kernel arguments
 * @param [in] sharedMemBytes - Amount of dynamic shared memory to allocate for
 * this kernel.  The Kernel can access this with TANG_DYNAMIC_SHARED.
 * @param [in] stream - Stream where the kernel should be dispatched.  May be 0,
 * in which case th default stream is used with associated synchronization
 * rules.
 *
 * @returns #tangSuccess, #tangErrorInvalidValue, tangInvalidDevice
 *
 */
TANGRT_API_PUBLIC tangError_t tangLaunchKernel(const void*           hostFunc,
                                               dim3                  gridDim,
                                               dim3                  blockDim,
                                               void**                args,
                                               size_t                numArgs,
                                               size_t sharedMemBytes __dparm(0),
                                               tangStream_t stream __dparm(0));

TANGRT_API_PUBLIC tangError_t
tangLaunchKernel_ptsz(const void*           hostFunc,
                      dim3                  gridDim,
                      dim3                  blockDim,
                      void**                args,
                      size_t                numArgs,
                      size_t sharedMemBytes __dparm(0),
                      tangStream_t stream   __dparm(0));

#ifdef __cplusplus
}
#endif

#if defined(__TANGRT_API_PER_THREAD_DEFAULT_STREAM)
#define tangLaunchKernel __TANGRT_API_PTSZ(tangLaunchKernel)
#endif  //! __TANGRT_API_PER_THREAD_DEFAULT_STREAM

#endif  //! _TANG_RT_TANG_COMPILER_API_H
